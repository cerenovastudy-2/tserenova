#  Алгоритмы и структуры данных


---

##  Алгоритмы сортировки

---

### 1. Сортировка выбором (Selection Sort)

**Определение:**
Алгоритм последовательно находит наименьший элемент в неотсортированной части массива и перемещает его в начало.

**Принцип работы:**
1. Проходим по массиву слева направо
2. Для каждой позиции находим минимальный элемент в оставшейся части
3. Меняем местами текущий элемент с найденным минимумом
4. Увеличиваем границу отсортированной части

**Сложность:** O(n²) - квадратичная

**Результат выполения:**
Исходный массив: 64 25 12 22 11 
Отсортированный массив: 11 12 22 25 64 

---

### 2. Сортировка пузырьком (Bubble Sort)

**Определение:**
Метод многократно проходит через массив, сравнивая и переставляя соседние элементы.

**Принцип работы:**
1. Последовательно сравниваем пары соседних элементов
2. Если порядок неправильный - меняем их местами
3. После каждого прохода самый большой элемент "всплывает" в конец
4. Процесс повторяется для уменьшенной области

**Сложность:**
- O(n²) - в худшем случае
- O(n) - в лучшем случае (уже отсортирован)

**Результат выполения:**
Исходный массив: 64 34 25 12 22 11 90 
Отсортированный массив: 11 12 22 25 34 64 90 

---

### 3. Сортировка вставками (Insertion Sort)

**Определение:**
Элементы по одному перемещаются в правильную позицию внутри уже отсортированной части массива.

**Принцип работы:**
1. Начинаем со второго элемента
2. Сравниваем с элементами в отсортированной части
3. Сдвигаем элементы больше текущего вправо
4. Вставляем элемент на найденное место

**Сложность:**
- O(n²) - в среднем случае
- O(n) - для почти отсортированных массивов

**Результат выполения:**
Исходный массив: 12 11 13 5 6 
Отсортированный массив: 5 6 11 12 13

---

### 4. Сортировка слиянием (Merge Sort)

**Определение:**
Рекурсивный алгоритм, разделяющий массив на мелкие части, сортирующий их и объединяющий обратно.

**Принцип работы:**
1. Рекурсивно делим массив пополам
2. Сортируем каждую половину
3. Объединяем отсортированные части в новый массив
4. Процесс продолжается до полной сортировки

**Сложность:** O(n log n) - гарантированная

**Результат выполения:**
Исходный массив: 38 27 43 3 9 82 10 
Отсортированный массив: 3 9 10 27 38 43 82 

---

### 5. Сортировка Шелла (Shell Sort)

**Определение:**
Усовершенствованная версия сортировки вставками с использованием убывающих интервалов.

**Принцип работы:**
1. Выбираем начальный шаг (обычно n/2)
2. Сортируем элементы на этом расстоянии
3. Уменьшаем шаг и повторяем
4. Завершаем с шагом 1 (обычная сортировка вставками)

**Сложность:** O(n log n) - в среднем

**Результат выполения:**
Исходный массив: 12 34 54 2 3 
Отсортированный массив: 2 3 12 34 54 

---

### 6. Быстрая сортировка (Quick Sort)

**Определение:**
Эффективный алгоритм, использующий стратегию "разделяй и властвуй" с выбором опорного элемента.

**Принцип работы:**
1. Выбираем опорный элемент
2. Разделяем массив на элементы меньше и больше опорного
3. Рекурсивно применяем алгоритм к обеим частям
4. Объединяем результаты

**Сложность:**
- O(n log n) - в среднем
- O(n²) - в худшем случае

**Результат выполения:**
Исходный массив: 10 7 8 9 1 5 
Отсортированный массив: 1 5 7 8 9 10 

---

### 7. Пирамидальная сортировка (Heap Sort)

**Определение:**
Алгоритм, использующий структуру данных "двоичная куча" для сортировки.

**Принцип работы:**
1. Преобразуем массив в max-кучу
2. Максимальный элемент находится в корне
3. Перемещаем корень в конец массива
4. Восстанавливаем свойства кучи для уменьшенного массива

**Сложность:** O(n log n) - стабильная

**Результат выполения:**
Исходный массив: 12 11 13 5 6 7 
Отсортированный массив: 5 6 7 11 12 13

---

##  Алгоритмы поиска

---

### 1. Линейный поиск (Linear Search)

**Определение:**
Линейный поиск — это простейший алгоритм поиска элемента в коллекции данных, который последовательно проверяет каждый элемент до тех пор, пока не будет найден искомый элемент или не будет достигнут конец коллекции.

**Принцип работы:**
1.Начало поиска
-Алгоритм начинает с первого элемента коллекции
-Устанавливается текущая позиция на индекс 0

2.Последовательная проверка
-На каждом шаге сравнивается текущий элемент с искомым значением
-Если элементы совпадают — поиск завершается успешно
-Если не совпадают — переход к следующему элементу

3.Условия завершения
-Успешное завершение: элемент найден, возвращается его индекс
-Неуспешное завершение: пройдены все элементы, возвращается значение "не найдено"


**Сложность:** O(n) - линейная

**Результат выполения:**
Элемент найден на позиции: 3

---

### 2. Бинарный поиск (Binary Search)

**Определение:**
Эффективный алгоритм для поиска в отсортированных массивах.

**Принцип работы:**
1. Определяем начальные границы поиска
2. Находим средний элемент
3. Сравниваем с искомым значением
4. Сужаем область поиска вдвое

**Сложность:** O(log n) - логарифмическая

**Резултат выполнения:**
Элемент найден на позиции: 3

---

### 3. Интерполяционный поиск (Interpolation Search)

**Определение:**
Улучшенный бинарный поиск для равномерно распределенных данных.

**Принцип работы:**
1. Вычисляем вероятную позицию элемента
2. Используем формулу интерполяции
3. Корректируем границы поиска
4. Повторяем до нахождения элемента

**Сложность:**
- O(log log n) - в лучшем случае
- O(n) - в худшем случае

**Резултат выполнения:**
Элемент найден на позиции: 4

---

### 4. Поиск Фибоначчи (Fibonacci Search)

**Определение:**
Алгоритм, использующий числа Фибоначчи для определения точек разделения.

**Принцип работы:**
1. Находим число Фибоначчи, большее длины массива
2. Используем числа Фибоначчи для определения позиций
3. Сравниваем элемент в вычисленной позиции
4. Сдвигаем границы поиска

**Сложность:** O(log n) - сравнима с бинарным поиском

**Резултат выполнения:**
Элемент найден на позиции: 8

---

Каждый алгоритм имеет свои преимущества и области применения, выбор зависит от конкретной задачи и характеристик данных.
