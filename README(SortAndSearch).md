#  Алгоритмы и структуры данных


Алгоритмы сортировки и поиска

Алгоритмы сортировки

1. Сортировка выбором (Selection Sort)

Определение: Алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части.

Пошаговая работа:

1. Находим минимальный элемент в неотсортированной части
2. Меняем его с первым элементом неотсортированной части
3. Увеличиваем отсортированную часть на один элемент
4. Повторяем для оставшейся части

Сложность: O(n²) во всех случаях

Объяснение сложности:

· Внешний цикл: выполняется n-1 раз
· Внутренний цикл: на i-ой итерации выполняется n-i сравнений
· Общее количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2
· Количество обменов: всегда n-1
· Алгоритм не адаптивный - всегда выполняет одинаковое количество операций независимо от входных данных

Пример:
Исходный массив: [29, 10, 14, 37, 13]
Шаг 1: min=10 → [10, 29, 14, 37, 13]
Шаг 2: min=13 → [10, 13, 14, 37, 29]
Шаг 3: min=14 → [10, 13, 14, 37, 29]
Шаг 4: min=29 → [10, 13, 14, 29, 37]
Отсортированный массив: [10, 13, 14, 29, 37]

---

2. Сортировка пузырьком (Bubble Sort)

Определение: Простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами при неправильном порядке.

Пошаговая работа:

1. Проходим по массиву, сравнивая соседние элементы
2. Если левый больше правого - меняем местами
3. После каждого прохода наибольший элемент "всплывает" в конец
4. Повторяем до полной сортировки

Сложность:

· Лучший случай: O(n)
· Средний случай: O(n²)
· Худший случай: O(n²)

Объяснение сложности:

· Лучший случай (O(n)): массив уже отсортирован, нужен только один проход без обменов
· Худший случай (O(n²)): массив отсортирован в обратном порядке
  · Количество сравнений: n(n-1)/2
  · Количество обменов: n(n-1)/2
· Средний случай (O(n²)): в среднем требуется n²/2 сравнений и n²/4 обменов
· Алгоритм адаптивный - может завершиться досрочно

Пример:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Проход 1: [34, 25, 12, 22, 11, 64, 90]
Проход 2: [25, 12, 22, 11, 34, 64, 90]
Проход 3: [12, 22, 11, 25, 34, 64, 90]
Проход 4: [12, 11, 22, 25, 34, 64, 90]
Проход 5: [11, 12, 22, 25, 34, 64, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

---

3. Сортировка вставками (Insertion Sort)

Определение: Алгоритм строит отсортированную часть массива, вставляя каждый новый элемент на правильное место.

Пошаговая работа:

1. Начинаем со второго элемента
2. Сравниваем с элементами отсортированной части
3. Сдвигаем элементы, большие текущего
4. Вставляем элемент на найденную позицию
5. Повторяем для всех элементов

Сложность:

· Лучший случай: O(n)
· Средний случай: O(n²)
· Худший случай: O(n²)

Объяснение сложности:

· Лучший случай (O(n)): массив уже отсортирован, каждый элемент сразу на своем месте
  · Количество сравнений: n-1
  · Количество сдвигов: 0
· Худший случай (O(n²)): массив отсортирован в обратном порядке
  · Количество сравнений: n(n-1)/2
  · Количество сдвигов: n(n-1)/2
· Средний случай (O(n²)): в среднем n²/4 сравнений и n²/8 сдвигов
· Эффективен для небольших массивов и почти отсортированных данных

Пример:
Исходный массив: [15, 8, 42, 4, 23, 16]
Вставляем 8: [8, 15, 42, 4, 23, 16]
Вставляем 42: [8, 15, 42, 4, 23, 16]
Вставляем 4:  [4, 8, 15, 42, 23, 16]
Вставляем 23: [4, 8, 15, 23, 42, 16]
Вставляем 16: [4, 8, 15, 16, 23, 42]
Отсортированный массив: [4, 8, 15, 16, 23, 42]

---

4. Сортировка слиянием (Merge Sort)

Определение: Алгоритм "разделяй и властвуй", который рекурсивно делит массив пополам и объединяет отсортированные части.

Пошаговая работа:

1. Делим массив пополам
2. Рекурсивно сортируем каждую половину
3. Объединяем отсортированные половины

Сложность: O(n log n) во всех случаях

Объяснение сложности:

· Рекурсивное деление: массив делится пополам log₂n раз
· Слияние на каждом уровне: O(n) операций
· Общая сложность: O(n) × O(log n) = O(n log n)
· Пространственная сложность: O(n) для временных массивов
· Стабильная сортировка, не адаптивная

Пример:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Делим: [38,27,43,3] [9,82,10]
Делим: [38,27] [43,3] [9,82] [10]
Сортируем: [27,38] [3,43] [9,82] [10]
Объединяем: [3,27,38,43] [9,10,82]
Объединяем: [3, 9, 10, 27, 38, 43, 82]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]

---

5. Сортировка Шелла (Shell Sort)

Определение: Улучшенная версия сортировки вставками с использованием убывающих интервалов.

Пошаговая работа:

1. Выбираем начальный шаг (gap)
2. Сортируем элементы с этим шагом
3. Уменьшаем шаг
4. Завершаем сортировку с шагом 1

Сложность:

· Лучший случай: O(n log n)
· Средний случай: O(n log n)
· Худший случай: O(n²)

Объяснение сложности:

· Зависит от последовательности шагов:
  · Последовательность Шелла: O(n²)
  · Последовательность Хиббарда: O(n^(3/2))
  · Последовательность Пратта: O(n log²n)
· Идея: крупные шаги перемещают элементы ближе к их конечным позициям
· Эффективность: между O(n log n) и O(n²) в зависимости от выбора шагов

Пример:
Исходный массив: [23, 12, 1, 8, 34, 54, 2, 3]
Шаг gap=4: [23, 12, 1, 8, 34, 54, 2, 3]
Шаг gap=2: [1, 8, 2, 3, 23, 12, 34, 54]
Шаг gap=1: [1, 2, 3, 8, 12, 23, 34, 54]
Отсортированный массив: [1, 2, 3, 8, 12, 23, 34, 54]

---
6. Быстрая сортировка (Quick Sort)

Определение: Алгоритм "разделяй и властвуй", который выбирает опорный элемент и делит массив на части.

Пошаговая работа:

1. Выбираем опорный элемент (обычно последний элемент массива)
2. Проходим по массиву слева направо, перемещая элементы меньше опорного влево
3. Элементы больше опорного остаются справа
4. Помещаем опорный элемент между этими двумя группами
5. Рекурсивно применяем алгоритм к левой и правой частям
6. Объединяем результаты

Сложность:

· Лучший случай: O(n log n)
· Средний случай: O(n log n)
· Худший случай: O(n²)

Объяснение сложности:

· Лучший/средний случай (O(n log n)): когда опорный элемент делит массив на примерно равные части
  · Глубина рекурсии: O(log n)
  · Работа на каждом уровне: O(n)
· Худший случай (O(n²)): когда массив уже отсортирован и опорный элемент всегда минимальный или максимальный
  · Глубина рекурсии: O(n)
  · Работа на каждом уровне: O(n)

Пример выполнения:
Исходный массив: [10, 7, 8, 9, 1, 5]
Опорный элемент: 5

Разделение:
- Элементы меньше 5: [1]
- Опорный элемент: 5
- Элементы больше 5: [10, 7, 8, 9]

Рекурсивная сортировка левой части [1]:
- Уже отсортирован

Рекурсивная сортировка правой части [10, 7, 8, 9]:
Опорный элемент: 9
- Элементы меньше 9: [7, 8]
- Опорный элемент: 9
- Элементы больше 9: [10]

Рекурсивная сортировка [7, 8]:
Опорный элемент: 8
- Элементы меньше 8: [7]
- Опорный элемент: 8
- Элементы больше 8: []

Объединяем все части:
[1] + [5] + [7, 8] + [9] + [10] = [1, 5, 7, 8, 9, 10]

Отсортированный массив: [1, 5, 7, 8, 9, 10]

---

7. Пирамидальная сортировка (Heap Sort)

Определение: Алгоритм, использующий структуру данных "куча" для упорядочивания элементов.

Пошаговая работа:

1. Преобразуем массив в max-кучу (родитель ≥ потомков)
2. Находим самый большой элемент (в корне кучи)
3. Меняем его с последним элементом массива
4. Уменьшаем размер кучи на 1
5. Восстанавливаем свойства max-кучи для нового корня
6. Повторяем шаги 2-5, пока куча не пуста

Сложность: O(n log n) во всех случаях

Объяснение сложности:

· Построение кучи: O(n) операций
· Извлечение элементов: n извлечений × O(log n) = O(n log n)
· Общая сложность: O(n) + O(n log n) = O(n log n)

Пример выполнения:
Исходный массив: [4, 10, 3, 5, 1]

Шаг 1: Построение max-кучи
Исходный: [4, 10, 3, 5, 1]
После heapify: [10, 5, 3, 4, 1]

Шаг 2: Извлекаем максимальный элемент (10)
Меняем 10 и 1: [1, 5, 3, 4, 10]
Восстанавливаем кучу: [5, 4, 3, 1, 10]

Шаг 3: Извлекаем максимальный элемент (5)
Меняем 5 и 1: [1, 4, 3, 5, 10]
Восстанавливаем кучу: [4, 1, 3, 5, 10]

Шаг 4: Извлекаем максимальный элемент (4)
Меняем 4 и 3: [3, 1, 4, 5, 10]
Восстанавливаем кучу: [3, 1, 4, 5, 10]

Шаг 5: Извлекаем максимальный элемент (3)
Меняем 3 и 1: [1, 3, 4, 5, 10]

Отсортированный массив: [1, 3, 4, 5, 10]

---

8. Линейный поиск (Linear Search)

Определение: Последовательно проверяет элементы массива один за другим.

Пошаговая работа:

1. Начинаем с первого элемента массива
2. Сравниваем текущий элемент с искомым значением
3. Если элементы равны - возвращаем индекс текущего элемента
4. Если не равны - переходим к следующему элементу
5. Повторяем шаги 2-4 до нахождения элемента или конца массива
6. Если элемент не найден - возвращаем -1

Сложность: O(n)

Объяснение сложности:

· Лучший случай (O(1)): элемент находится на первой позиции
· Средний случай (O(n)): элемент находится в середине массива
· Худший случай (O(n)): элемент отсутствует или находится на последней позиции

Пример выполнения:
Массив: [3, 5, 2, 7, 9, 1, 4]
Ищем элемент: 7

Шаг 1: Проверяем элемент 3 на позиции 0 → 3 ≠ 7
Шаг 2: Проверяем элемент 5 на позиции 1 → 5 ≠ 7
Шаг 3: Проверяем элемент 2 на позиции 2 → 2 ≠ 7
Шаг 4: Проверяем элемент 7 на позиции 3 → 7 = 7 ✓

Элемент найден на позиции: 3

---

9. Бинарный поиск (Binary Search)

Определение: Работает на отсортированном массиве, делит диапазон поиска пополам на каждом шаге.

Пошаговая работа:

1. Определяем начальные границы поиска (left = 0, right = n-1)
2. Вычисляем средний индекс: mid = (left + right) // 2
3. Сравниваем элемент в mid с искомым значением
4.Если равны - возвращаем mid
5. Если искомое значение меньше - ищем в левой половине (right = mid - 1)
6. Если искомое значение больше - ищем в правой половине (left = mid + 1)
7. Повторяем шаги 2-6 пока left ≤ right
8. Если элемент не найден - возвращаем -1

Сложность: O(log n)

Объяснение сложности:

· Каждый шаг уменьшает область поиска вдвое
· Количество шагов: log₂n

Пример выполнения:
Отсортированный массив: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Ищем элемент: 7

Шаг 1: left=0, right=9, mid=4 → arr[4]=9 > 7 → ищем слева
Шаг 2: left=0, right=3, mid=1 → arr[1]=3 < 7 → ищем справа
Шаг 3: left=2, right=3, mid=2 → arr[2]=5 < 7 → ищем справа
Шаг 4: left=3, right=3, mid=3 → arr[3]=7 = 7 ✓

Элемент найден на позиции: 3

---

10. Интерполяционный поиск (Interpolation Search)

Определение: Улучшенный бинарный поиск для равномерно распределённых данных.

Пошаговая работа:

1. Вычисляем предполагаемую позицию по формуле:
   pos = low + ((target - arr[low]) × (high - low)) / (arr[high] - arr[low])
2. Сравниваем элемент в позиции pos с искомым значением
3. Если равны - возвращаем pos
4. Если искомое значение меньше - ищем в левой части (high = pos - 1)
5. Если искомое значение больше - ищем в правой части (low = pos + 1)
6. Повторяем шаги 1-5 пока low ≤ high и target в диапазоне [arr[low], arr[high]]
7. Если элемент не найден - возвращаем -1

Сложность:

· Лучший случай: O(1)
· Средний случай: O(log log n)
· Худший случай: O(n)

Объяснение сложности:

· Лучший случай: точное предсказание позиции
· Средний случай: для равномерных данных быстро сужает область поиска
· Худший случай: для неравномерных данных вырождается в линейный поиск

Пример выполнения:
Отсортированный массив: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
Ищем элемент: 60

Шаг 1: low=0, high=9
pos = 0 + ((60-10)×(9-0))/(100-10) = 0 + (50×9)/90 = 5
arr[5] = 60 = 60 ✓

Элемент найден на позиции: 5

---

11. Поиск Фибоначчи (Fibonacci Search)

Определение: Алгоритм поиска, использующий числа Фибоначчи для деления массива.

Пошаговая работа:

1. Находим наименьшее число Фибоначчи F(k) ≥ длины массива
2. Инициализируем переменные: fibM = F(k), fibM1 = F(k-1), fibM2 = F(k-2)
3. Устанавливаем начальный offset = -1
4. Пока fibM > 1:
   · Вычисляем индекс i = min(offset + fibM2, n-1)
   · Сравниваем arr[i] с искомым значением
   · Если равны - возвращаем i
   · Если искомое значение больше - сдвигаемся вправо, обновляем числа Фибоначчи
   · Если искомое значение меньше - сдвигаемся влево, обновляем числа Фибоначчи
5. Проверяем последний элемент если нужно
6. Если элемент не найден - возвращаем -1

Сложность: O(log n)

Объяснение сложности:

· Основан на свойствах чисел Фибоначчи
· Каждый шаг уменьшает область поиска используя золотое сечение
· Эффективность сравнима с бинарным поиском

Пример выполнения:
Отсортированный массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Ищем элемент: 85

Числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13 (F(7)=13 ≥ 11)

Шаг 1: fibM=13, fibM1=8, fibM2=5, offset=-1
i = min(-1 + 5, 10) = 4 → arr[4]=45 < 85 → сдвиг вправо

Шаг 2: fibM=8, fibM1=5, fibM2=3, offset=4
i = min(4 + 3, 10) = 7 → arr[7]=82 < 85 → сдвиг вправо

Шаг 3: fibM=5, fibM1=3, fibM2=2, offset=7
i = min(7 + 2, 10) = 9 → arr[9]=90 > 85 → сдвиг влево

Шаг 4: fibM=2, fibM1=1, fibM2=1, offset=7
i = min(7 + 1, 10) = 8 → arr[8]=85 = 85 ✓

Элемент найден на позиции: 8
