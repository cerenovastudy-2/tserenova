#  Алгоритмы и структуры данных


---

##  Алгоритмы сортировки

---

### 1. Сортировка выбором (Selection Sort)

**Определение:**
Алгоритм последовательно находит наименьший элемент в неотсортированной части массива и перемещает его в начало.

**Принцип работы:**
1. Начинаем с первого элемента массива (`for i in range(n)`)
2. Находим минимальный элемент в неотсортированной части (`for j in range(i + 1, n)`, `if arr[j] < arr[min_idx]`)
3. Меняем местами найденный минимальный элемент с текущим (`arr[i], arr[min_idx] = arr[min_idx], arr[i]`)
4. Увеличиваем отсортированную часть на один элемент (`i += 1`)
5. Повторяем процесс для оставшейся части массива

**Сложность:** O(n²) - квадратичная

**Результат выполения:**
- Исходный массив: 64 25 12 22 11 
- Отсортированный массив: 11 12 22 25 64 

---

### 2. Сортировка пузырьком (Bubble Sort)

**Определение:**
Метод многократно проходит через массив, сравнивая и переставляя соседние элементы.

**Принцип работы:**
1. Проходим по массиву несколько раз (`for i in range(n)`)
2. Сравниваем соседние элементы (`if arr[j] > arr[j + 1]`)
3. Если левый больше правого, меняем их местами (`arr[j], arr[j + 1] = arr[j + 1], arr[j]`)
4. После каждого прохода наибольший элемент "всплывает" в конец
5. Повторяем до полной сортировки


**Сложность:**
- O(n²) - в худшем случае
- O(n) - в лучшем случае (уже отсортирован)

**Результат выполения:**
- Исходный массив: 64 34 25 12 22 11 90 
- Отсортированный массив: 11 12 22 25 34 64 90 

---

### 3. Сортировка вставками (Insertion Sort)

**Определение:**
Элементы по одному перемещаются в правильную позицию внутри уже отсортированной части массива.

**Принцип работы:**
1. Начинаем со второго элемента (`for i in range(1, len(arr))`)
2. Запоминаем текущий элемент (`key = arr[i]`)
3. Сдвигаем элементы, большие текущего, вправо (`while j >= 0 and arr[j] > key`, `arr[j + 1] = arr[j]`)
4. Вставляем элемент на найденную позицию (`arr[j + 1] = key`)
5. Повторяем для всех элементов


**Сложность:**
- O(n²) - в среднем случае
- O(n) - для почти отсортированных массивов

**Результат выполения:**
- Исходный массив: 12 11 13 5 6 
- Отсортированный массив: 5 6 11 12 13

---

### 4. Сортировка слиянием (Merge Sort)

**Определение:**
Рекурсивный алгоритм, разделяющий массив на мелкие части, сортирующий их и объединяющий обратно.

**Принцип работы:**
1. Разделяем массив пополам (`mid = len(arr) // 2`)
2. Рекурсивно сортируем левую и правую половины (`merge_sort(left)`, `merge_sort(right)`)
3. Объединяем отсортированные половины (`while i < len(L) and j < len(R)`)
4. Сравниваем элементы из двух половин (`if L[i] <= R[j]`)
5. Добавляем оставшиеся элементы (`while i < len(L)`, `while j < len(R)`)


**Сложность:** O(n log n) - гарантированная

**Результат выполения:**
- Исходный массив: 38 27 43 3 9 82 10 
- Отсортированный массив: 3 9 10 27 38 43 82 

---

### 5. Сортировка Шелла (Shell Sort)

**Определение:**
Усовершенствованная версия сортировки вставками с использованием убывающих интервалов.

**Принцип работы:**
1. Выбираем начальный шаг (расстояние) (gap = len(arr) // 2)
2. Сортируем элементы на этом расстоянии методом вставок (for i in range(gap, n))
3. Сравниваем и перемещаем элементы на расстоянии gap (while j >= gap and arr[j - gap] > temp)
4. Уменьшаем шаг и повторяем процесс (gap //= 2)
5. Завершаем сортировку с шагом 1 (обычная сортировка вставками)

**Сложность:** O(n log n) - в среднем

**Результат выполения:**
- Исходный массив: 12 34 54 2 3 
- Отсортированный массив: 2 3 12 34 54 

---

### 6. Быстрая сортировка (Quick Sort)

**Определение:**
Эффективный алгоритм, использующий стратегию "разделяй и властвуй" с выбором опорного элемента.

**Принцип работы:**
1. Выбираем опорный элемент (`pivot = arr[high]`)
2. Делим массив на элементы меньше и больше опорного (`for j in range(low, high)`)
3. Размещаем опорный элемент в правильной позиции (`arr[i + 1], arr[high] = arr[high], arr[i + 1]`)
4. Рекурсивно применяем к обеим частям (`quick_sort(arr, low, pi - 1)`, `quick_sort(arr, pi + 1, high)`)


**Сложность:**
- O(n log n) - в среднем
- O(n²) - в худшем случае

**Результат выполения:**
- Исходный массив: 10 7 8 9 1 5 
- Отсортированный массив: 1 5 7 8 9 10 

---

### 7. Пирамидальная сортировка (Heap Sort)

**Определение:**
Алгоритм, использующий структуру данных "двоичная куча" для сортировки.

**Принцип работы:**
1. Строим max-кучу из массива (`for i in range(n // 2 - 1, -1, -1)`, `heapify(arr, n, i)`)
2. Корень кучи содержит максимальный элемент
3. Меняем корень с последним элементом (`arr[i], arr[0] = arr[0], arr[i]`)
4. Восстанавливаем свойства кучи (`heapify(arr, i, 0)`)
5. Повторяем, пока куча не пуста

**Сложность:** O(n log n) - стабильная

**Результат выполения:**
- Исходный массив: 12 11 13 5 6 7 
- Отсортированный массив: 5 6 7 11 12 13

---

##  Алгоритмы поиска

---

### 1. Линейный поиск (Linear Search)

**Определение:**
Линейный поиск — это простейший алгоритм поиска элемента в коллекции данных, который последовательно проверяет каждый элемент до тех пор, пока не будет найден искомый элемент или не будет достигнут конец коллекции.

**Принцип работы:**
1. Начинаем с первого элемента массива (`for i in range(len(arr))`)
2. Сравниваем каждый элемент с искомым (`if arr[i] == target`)
3. Если найден — возвращаем индекс (`return i`)
4. Если дошли до конца — возвращаем -1 (`return -1`)

**Сложность:** O(n) - линейная

**Результат выполения:**
- Элемент найден на позиции: 3

---

### 2. Бинарный поиск (Binary Search)

**Определение:**
Эффективный алгоритм для поиска в отсортированных массивах.

**Принцип работы:**
1. Определяем левую и правую границы (`left, right = 0, len(arr) - 1`)
2. Находим средний элемент (`mid = (left + right) // 2`)
3. Сравниваем его с искомым (`if arr[mid] == target`, `elif arr[mid] < target`)
4. Сужаем диапазон поиска (`left = mid + 1`, `right = mid - 1`)
5. Повторяем пока границы не сойдутся

**Сложность:** O(log n) - логарифмическая

**Резултат выполнения:**
- Элемент найден на позиции: 3

---

### 3. Интерполяционный поиск (Interpolation Search)

**Определение:**
Улучшенный бинарный поиск для равномерно распределенных данных.

**Принцип работы:**
1. Вычисляем предполагаемую позицию элемента по формуле (`pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])`)
2. Сравниваем найденный элемент с искомым (`if arr[pos] == target`)
3. Сужаем область поиска (`low = pos + 1`, `high = pos - 1`)
4. Повторяем пока элемент не найден или границы не пересекутся

**Сложность:**
- O(log log n) - в лучшем случае
- O(n) - в худшем случае

**Резултат выполнения:**
- Элемент найден на позиции: 4

---

### 4. Поиск Фибоначчи (Fibonacci Search)

**Определение:**
Алгоритм, использующий числа Фибоначчи для определения точек разделения.

**Принцип работы:**
1. Находим число Фибоначчи ≥ длины массива (`while fib < n:`, `fib2, fib1, fib = fib1, fib, fib1 + fib`)
2. Определяем позиции для сравнения (`offset = -1`, `i = min(offset + fib2, n - 1)`)
3. Сравниваем элемент в точке разделения с искомым (`if arr[i] < target`, `elif arr[i] > target`)
4. Сдвигаем область поиска в зависимости от результата


**Сложность:** O(log n) - сравнима с бинарным поиском

**Резултат выполнения:**
- Элемент найден на позиции: 8


