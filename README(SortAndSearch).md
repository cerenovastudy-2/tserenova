#  Алгоритмы и структуры данных


---

##  Алгоритмы сортировки

---

### 1. Сортировка выбором (Selection Sort)

**Определение:**
Алгоритм последовательно находит наименьший элемент в неотсортированной части массива и перемещает его в начало.

**Принцип работы:**
1. Начинаем с первого элемента массива (`for i in range(n)`)
2. Находим минимальный элемент в неотсортированной части (`for j in range(i + 1, n)`, `if arr[j] < arr[min_idx]`)
3. Меняем местами найденный минимальный элемент с текущим (`arr[i], arr[min_idx] = arr[min_idx], arr[i]`)
4. Увеличиваем отсортированную часть на один элемент (`i += 1`)
5. Повторяем процесс для оставшейся части массива

**Временная Сложность:** O(n²) - квадратичная. два вложенных цикла, каждый размером ~n. · Два вложенных цикла: внешний n итераций, внутренний n/2 итераций в среднем
· Всегда выполняется ≈ n²/2 сравнений

**Результат выполения:**
- Исходный массив: 64 25 12 22 11 
- Процесс сортировки:
- Шаг 1: 11 25 12 22 64 
- Шаг 2: 11 12 25 22 64 
- Шаг 3: 11 12 22 25 64 
- Шаг 4: 11 12 22 25 64 
- Отсортированный массив: 11 12 22 25 64 


---

### 2. Сортировка пузырьком (Bubble Sort)

**Определение:**
Метод многократно проходит через массив, сравнивая и переставляя соседние элементы.

**Принцип работы:**
1. Проходим по массиву несколько раз (`for i in range(n)`)
2. Сравниваем соседние элементы (`if arr[j] > arr[j + 1]`)
3. Если левый больше правого, меняем их местами (`arr[j], arr[j + 1] = arr[j + 1], arr[j]`)
4. После каждого прохода наибольший элемент "всплывает" в конец
5. Повторяем до полной сортировки


**Временная Сложность:**

· Лучший: O(n) - один проход по уже отсортированному массиву
· Средний: O(n²) - два вложенных цикла
· Худший: O(n²) - максимальное количество сравнений и обменов


**Результат выполения:**
- Исходный массив: [64, 34, 25, 12, 22, 11, 90]
- Процесс сортировки:
Шаг 1: [34, 25, 12, 22, 11, 64, 90]
Шаг 2: [25, 12, 22, 11, 34, 64, 90]
Шаг 3: [12, 22, 11, 25, 34, 64, 90]
Шаг 4: [12, 11, 22, 25, 34, 64, 90]
Шаг 5: [11, 12, 22, 25, 34, 64, 90]
Шаг 6: [11, 12, 22, 25, 34, 64, 90]
- Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]


---

### 3. Сортировка вставками (Insertion Sort)

**Определение:**
Элементы по одному перемещаются в правильную позицию внутри уже отсортированной части массива.

**Принцип работы:**
1. Начинаем со второго элемента (`for i in range(1, len(arr))`)
2. Запоминаем текущий элемент (`key = arr[i]`)
3. Сдвигаем элементы, большие текущего, вправо (`while j >= 0 and arr[j] > key`, `arr[j + 1] = arr[j]`)
4. Вставляем элемент на найденную позицию (`arr[j + 1] = key`)
5. Повторяем для всех элементов


**Временная Сложность:**

· Лучший: O(n) - каждый элемент сразу на своем месте
· Средний: O(n²) - в среднем n/4 сдвигов на элемент
· Худший: O(n²) - каждый элемент сдвигается в начало

**Результат выполения:**
- Исходный массив: 12 11 13 5 6 
- Процесс сортировки:
Шаг 1: 11 12 13 5 6 
Шаг 2: 11 12 13 5 6 
Шаг 3: 5 11 12 13 6 
Шаг 4: 5 6 11 12 13 
- Отсортированный массив: 5 6 11 12 13 


---

### 4. Сортировка слиянием (Merge Sort)

**Определение:**
Рекурсивный алгоритм, разделяющий массив на мелкие части, сортирующий их и объединяющий обратно.

**Принцип работы:**
1. Разделяем массив пополам (`mid = len(arr) // 2`)
2. Рекурсивно сортируем левую и правую половины (`merge_sort(left)`, `merge_sort(right)`)
3. Объединяем отсортированные половины (`while i < len(L) and j < len(R)`)
4. Сравниваем элементы из двух половин (`if L[i] <= R[j]`)
5. Добавляем оставшиеся элементы (`while i < len(L)`, `while j < len(R)`)


**Временная Сложность:** · На каждом шаге область поиска уменьшается вдвое
· Для массива из n элементов нужно log₂(n) шагов
· Очень эффективен для больших отсортированных массивов

**Результат выполения:**
- Исходный массив: 38 27 43 3 9 82 10 
Слияние: 27 38 
Слияние: 3 43 
Слияние: 3 27 38 43 
Слияние: 9 82 
Слияние: 9 10 82 
Слияние: 3 9 10 27 38 43 82 
- Отсортированный массив: 3 9 10 27 38 43 82 


---

### 5. Сортировка Шелла (Shell Sort)

**Определение:**
Усовершенствованная версия сортировки вставками с использованием убывающих интервалов.

**Принцип работы:**
1. Выбираем начальный шаг (расстояние) (gap = len(arr) // 2)
2. Сортируем элементы на этом расстоянии методом вставок (for i in range(gap, n))
3. Сравниваем и перемещаем элементы на расстоянии gap (while j >= gap and arr[j - gap] > temp)
4. Уменьшаем шаг и повторяем процесс (gap //= 2)
5. Завершаем сортировку с шагом 1 (обычная сортировка вставками)

**Временная Сложность:**Сложность: · Лучший: O(n log n) - опорный элемент делит массив пополам
· Средний: O(n log n) - в среднем хорошее разбиение
· Худший: O(n²) - когда опорный элемент минимальный/максимальный
**Результат выполения:**
Исходный массив: [12, 34, 54, 2, 3]
Шаг 1, gap = 2:
  i=2: [12, 34, 54, 2, 3]
  i=3: [2, 34, 54, 12, 3]
  i=4: [2, 3, 54, 12, 34]
Шаг 2, gap = 1:
  i=1: [2, 3, 54, 12, 34]
  i=2: [2, 3, 12, 54, 34]
  i=3: [2, 3, 12, 34, 54]
  i=4: [2, 3, 12, 34, 54]
Отсортированный массив: [2, 3, 12, 34, 54]


---

### 6. Быстрая сортировка (Quick Sort)

**Определение:**
Эффективный алгоритм, использующий стратегию "разделяй и властвуй" с выбором опорного элемента.

**Принцип работы:**
1. Выбираем опорный элемент (`pivot = arr[high]`)
2. Делим массив на элементы меньше и больше опорного (`for j in range(low, high)`)
3. Размещаем опорный элемент в правильной позиции (`arr[i + 1], arr[high] = arr[high], arr[i + 1]`)
4. Рекурсивно применяем к обеим частям (`quick_sort(arr, low, pi - 1)`, `quick_sort(arr, pi + 1, high)`)


**Временная Сложность:**

O(n)
· В худшем случае проверяются все n элементов
· Пространственная сложность постоянна O(1)
· Подходит для небольших или неотсортированных массивов

**Результат выполения:**
Исходный массив: [10, 7, 8, 9, 1, 5]
Опорный элемент 5 на позиции 0: [10, 7, 8, 9, 1, 5]
  Опорный элемент 1 на позиции 0: [1, 5]
  Опорный элемент 9 на позиции 3: [7, 8, 9, 10]
    Опорный элемент 8 на позиции 1: [7, 8]
Отсортированный массив: [1, 5, 7, 8, 9, 10]


---

### 7. Пирамидальная сортировка (Heap Sort)

**Определение:**
Алгоритм, использующий структуру данных "двоичная куча" для сортировки.

**Принцип работы:**
1. Строим max-кучу из массива (`for i in range(n // 2 - 1, -1, -1)`, `heapify(arr, n, i)`)
2. Корень кучи содержит максимальный элемент
3. Меняем корень с последним элементом (`arr[i], arr[0] = arr[0], arr[i]`)
4. Восстанавливаем свойства кучи (`heapify(arr, i, 0)`)
5. Повторяем, пока куча не пуста

**Временная Сложность:**
O(n log n) во всех случаях

· Построение кучи: O(n) операций
· Извлечение элементов: n извлечений × O(log n) = O(n log n)
· Итого: O(n) + O(n log n) = O(n log n)


**Результат выполения:**
Исходный массив: 12 11 13 5 6 7 
Построение кучи:
  Куча из 2: 12 11 13 5 6 7 
  Куча из 1: 12 11 13 5 6 7 
  Куча из 0: 13 11 12 5 6 7 
Извлечение элементов:
  Шаг 1: 12 11 7 5 6 13 
  Шаг 2: 11 6 7 5 12 13 
  Шаг 3: 7 6 5 11 12 13 
  Шаг 4: 6 5 7 11 12 13 
  Шаг 5: 5 6 7 11 12 13 
Отсортированный массив: 5 6 7 11 12 13 


---

##  Алгоритмы поиска

---

### 1. Линейный поиск (Linear Search)

**Определение:**
Линейный поиск — это простейший алгоритм поиска элемента в коллекции данных, который последовательно проверяет каждый элемент до тех пор, пока не будет найден искомый элемент или не будет достигнут конец коллекции.

**Принцип работы:**
1. Начинаем с первого элемента массива (`for i in range(len(arr))`)
2. Сравниваем каждый элемент с искомым (`if arr[i] == target`)
3. Если найден — возвращаем индекс (`return i`)
4. Если дошли до конца — возвращаем -1 (`return -1`)

**Временная Сложность:** 
O(n)

· Лучший: O(1) - элемент найден сразу
· Средний: O(n) - в среднем n/2 сравнений
· Худший: O(n) - проверяем все элементы



**Результат выполения:**
Исходный массив: [3, 5, 2, 7, 9, 1, 4]
Ищем элемент: 7
Процесс поиска:
  Проверяем элемент 3 на позиции 0
  Проверяем элемент 5 на позиции 1
  Проверяем элемент 2 на позиции 2
  Проверяем элемент 7 на позиции 3
Результат: элемент найден на позиции 3


---

### 2. Бинарный поиск (Binary Search)

**Определение:**
Эффективный алгоритм для поиска в отсортированных массивах.

**Принцип работы:**
1. Определяем левую и правую границы (`left, right = 0, len(arr) - 1`)
2. Находим средний элемент (`mid = (left + right) // 2`)
3. Сравниваем его с искомым (`if arr[mid] == target`, `elif arr[mid] < target`)
4. Сужаем диапазон поиска (`left = mid + 1`, `right = mid - 1`)
5. Повторяем пока границы не сойдутся

**Временная Сложность:** 
O(log n)

· Лучший: O(1) - элемент сразу в середине
· Средний: O(log n) - log₂(n) сравнений
· Худший: O(log n) - элемент на границе
**Резултат выполнения:**
Исходный массив: 1 3 5 7 9 11 13 15 17 19 
Ищем элемент: 7
Процесс поиска:
  left=0, right=9, mid=4 (arr[4]=9)
  left=0, right=3, mid=1 (arr[1]=3)
  left=2, right=3, mid=2 (arr[2]=5)
  left=3, right=3, mid=3 (arr[3]=7)
Результат: элемент найден на позиции 3


---

### 3. Интерполяционный поиск (Interpolation Search)

**Определение:**
Улучшенный бинарный поиск для равномерно распределенных данных.

**Принцип работы:**
1. Вычисляем предполагаемую позицию элемента по формуле (`pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])`)
2. Сравниваем найденный элемент с искомым (`if arr[pos] == target`)
3. Сужаем область поиска (`low = pos + 1`, `high = pos - 1`)
4. Повторяем пока элемент не найден или границы не пересекутся

**Временная Сложность:**
 Лучший: O(1) - сразу находим элемент
· Средний: O(log log n) - для равномерного распределения

· Худший: O(n) - когда данные распределены неравномерно

**Резултат выполнения:**
Исходный массив: 10 12 13 16 18 19 20 21 22 23 24 33 35 42 47 
Ищем элемент: 18
Процесс поиска:
  low=0, high=14, pos=4 (arr[4]=18)
Результат: элемент найден на позиции 4


---

### 4. Поиск Фибоначчи (Fibonacci Search)

**Определение:**
Алгоритм, использующий числа Фибоначчи для определения точек разделения.

**Принцип работы:**
1. Находим число Фибоначчи ≥ длины массива (`while fib < n:`, `fib2, fib1, fib = fib1, fib, fib1 + fib`)
2. Определяем позиции для сравнения (`offset = -1`, `i = min(offset + fib2, n - 1)`)
3. Сравниваем элемент в точке разделения с искомым (`if arr[i] < target`, `elif arr[i] > target`)
4. Сдвигаем область поиска в зависимости от результата




**Временная Сложность:**
· Лучший: O(1) - элемент найден на первой проверке
· Средний: O(log n) - аналогично бинарному поиску
· Худший: O(log n) - последовательное деление массива

**Резултат выполнения:**
Исходный массив: [10, сходный массив: [10, 22, 35, 22, 35, 4040, 45, , 45, 50,50, 80,  80, 82,82, 85,  85, 90,90, 100]
И 100]
Ищем элементщем элемент: 85
: 85
ГенГенерация чисел Фибонаерация чисел Фибоначчиччи:
  F:
  F(0, 1, 1)
  F(1, 1, 2)
  F(1, 2, 3)
  F(2, 3,(0, 1, 1)
  F(1, 1, 2)
  F(1, 2, 3)
  F(2, 3, 5)
  F( 5)
  F(3, 5, 3, 5, 8)
  F(58)
  F(5, 8, 13)
, 8, 13Начальный offset: -1)
Начальный offset: -
  Проверяем1
  Проверяем позицию 4: arr позицию 4: arr[4] = 45[4] = 45
    Сдвиг
    Сдвиг вправо, новый offset: 4
  Проверяем позицию 7 вправо, новый offset: 4
  Проверяем позицию 7: arr[7]: arr[7] = = 82
    82
    Сдвиг вправо Сдвиг впра, новыйво, новый offset offset: 7
  Проверяем пози: 7
  Проверяем позициюцию 9: arr[9] =  9: arr[9] = 90
90
    Сдвиг влево
    Сдвиг влево
  Проверяем позицию 8: arr[8  Проверяем позицию 8: arr[8] = 85
Ре] = 85
Результазультат: элемент найдент: элемент найден на на позиции 8



