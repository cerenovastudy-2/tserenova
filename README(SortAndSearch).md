#  Алгоритмы и структуры данных


Алгоритмы сортировки и поиска

Алгоритмы сортировки

1. Сортировка выбором (Selection Sort)

Определение: Алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части.

Пошаговая работа:

1. Находим минимальный элемент в неотсортированной части
2. Меняем его с первым элементом неотсортированной части
3. Увеличиваем отсортированную часть на один элемент
4. Повторяем для оставшейся части

Сложность: O(n²) во всех случаях

Объяснение сложности:

· Внешний цикл: выполняется n-1 раз
· Внутренний цикл: на i-ой итерации выполняется n-i сравнений
· Общее количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2
· Количество обменов: всегда n-1
· Алгоритм не адаптивный - всегда выполняет одинаковое количество операций независимо от входных данных

Пример:
Исходный массив: [29, 10, 14, 37, 13]
Шаг 1: min=10 → [10, 29, 14, 37, 13]
Шаг 2: min=13 → [10, 13, 14, 37, 29]
Шаг 3: min=14 → [10, 13, 14, 37, 29]
Шаг 4: min=29 → [10, 13, 14, 29, 37]
Отсортированный массив: [10, 13, 14, 29, 37]

---

2. Сортировка пузырьком (Bubble Sort)

Определение: Простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами при неправильном порядке.

Пошаговая работа:

1. Проходим по массиву, сравнивая соседние элементы
2. Если левый больше правого - меняем местами
3. После каждого прохода наибольший элемент "всплывает" в конец
4. Повторяем до полной сортировки

Сложность:

· Лучший случай: O(n)
· Средний случай: O(n²)
· Худший случай: O(n²)

Объяснение сложности:

· Лучший случай (O(n)): массив уже отсортирован, нужен только один проход без обменов
· Худший случай (O(n²)): массив отсортирован в обратном порядке
  · Количество сравнений: n(n-1)/2
  · Количество обменов: n(n-1)/2
· Средний случай (O(n²)): в среднем требуется n²/2 сравнений и n²/4 обменов
· Алгоритм адаптивный - может завершиться досрочно

Пример:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Проход 1: [34, 25, 12, 22, 11, 64, 90]
Проход 2: [25, 12, 22, 11, 34, 64, 90]
Проход 3: [12, 22, 11, 25, 34, 64, 90]
Проход 4: [12, 11, 22, 25, 34, 64, 90]
Проход 5: [11, 12, 22, 25, 34, 64, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

---

3. Сортировка вставками (Insertion Sort)

Определение: Алгоритм строит отсортированную часть массива, вставляя каждый новый элемент на правильное место.

Пошаговая работа:

1. Начинаем со второго элемента
2. Сравниваем с элементами отсортированной части
3. Сдвигаем элементы, большие текущего
4. Вставляем элемент на найденную позицию
5. Повторяем для всех элементов

Сложность:

· Лучший случай: O(n)
· Средний случай: O(n²)
· Худший случай: O(n²)

Объяснение сложности:

· Лучший случай (O(n)): массив уже отсортирован, каждый элемент сразу на своем месте
  · Количество сравнений: n-1
  · Количество сдвигов: 0
· Худший случай (O(n²)): массив отсортирован в обратном порядке
  · Количество сравнений: n(n-1)/2
  · Количество сдвигов: n(n-1)/2
· Средний случай (O(n²)): в среднем n²/4 сравнений и n²/8 сдвигов
· Эффективен для небольших массивов и почти отсортированных данных

Пример:
Исходный массив: [15, 8, 42, 4, 23, 16]
Вставляем 8: [8, 15, 42, 4, 23, 16]
Вставляем 42: [8, 15, 42, 4, 23, 16]
Вставляем 4:  [4, 8, 15, 42, 23, 16]
Вставляем 23: [4, 8, 15, 23, 42, 16]
Вставляем 16: [4, 8, 15, 16, 23, 42]
Отсортированный массив: [4, 8, 15, 16, 23, 42]

---

4. Сортировка слиянием (Merge Sort)

Определение: Алгоритм "разделяй и властвуй", который рекурсивно делит массив пополам и объединяет отсортированные части.

Пошаговая работа:

1. Делим массив пополам
2. Рекурсивно сортируем каждую половину
3. Объединяем отсортированные половины

Сложность: O(n log n) во всех случаях

Объяснение сложности:

· Рекурсивное деление: массив делится пополам log₂n раз
· Слияние на каждом уровне: O(n) операций
· Общая сложность: O(n) × O(log n) = O(n log n)
· Пространственная сложность: O(n) для временных массивов
· Стабильная сортировка, не адаптивная

Пример:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Делим: [38,27,43,3] [9,82,10]
Делим: [38,27] [43,3] [9,82] [10]
Сортируем: [27,38] [3,43] [9,82] [10]
Объединяем: [3,27,38,43] [9,10,82]
Объединяем: [3, 9, 10, 27, 38, 43, 82]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]

---

5. Сортировка Шелла (Shell Sort)

Определение: Улучшенная версия сортировки вставками с использованием убывающих интервалов.

Пошаговая работа:

1. Выбираем начальный шаг (gap)
2. Сортируем элементы с этим шагом
3. Уменьшаем шаг
4. Завершаем сортировку с шагом 1

Сложность:

· Лучший случай: O(n log n)
· Средний случай: O(n log n)
· Худший случай: O(n²)

Объяснение сложности:

· Зависит от последовательности шагов:
  · Последовательность Шелла: O(n²)
  · Последовательность Хиббарда: O(n^(3/2))
  · Последовательность Пратта: O(n log²n)
· Идея: крупные шаги перемещают элементы ближе к их конечным позициям
· Эффективность: между O(n log n) и O(n²) в зависимости от выбора шагов

Пример:
Исходный массив: [23, 12, 1, 8, 34, 54, 2, 3]
Шаг gap=4: [23, 12, 1, 8, 34, 54, 2, 3]
Шаг gap=2: [1, 8, 2, 3, 23, 12, 34, 54]
Шаг gap=1: [1, 2, 3, 8, 12, 23, 34, 54]
Отсортированный массив: [1, 2, 3, 8, 12, 23, 34, 54]

---

6. Быстрая сортировка (Quick Sort)

Определение: Алгоритм "разделяй и властвуй", который выбирает опорный элемент и делит массив на части.

Пошаговая работа:

1. Выбираем опорный элемент
2. Делим массив на элементы меньше и больше опорного
3. Рекурсивно сортируем обе части
4. Объединяем результат

Сложность:

· Лучший случай: O(n log n)
· Средний случай: O(n log n)
· Худший случай: O(n²)

Объяснение сложности:

· Лучший/средний случай (O(n log n)): сбалансированное разбиение
  · Глубина рекурсии: O(log n)
  · Работа на каждом уровне: O(n)
· Худший случай (O(n²)): несбалансированное разбиение (уже отсортированный массив)
  · Глубина рекурсии: O(n)
  · Работа на каждом уровне: O(n)
· На практике: один из самых быстрых алгоритмов

Пример:
Исходный массив: [24, 15, 38, 2, 19, 41, 8]
Опорный элемент 19: [15, 2, 8] 19 [24, 38, 41]
Сортируем левую: [2, 8, 15]
Сортируем правую: [24, 38, 41]
Объединяем: [2, 8, 15, 19, 24, 38, 41]
Отсортированный массив: [2, 8, 15, 19, 24, 38, 41]

---

7. Пирамидальная сортировка (Heap Sort)

Определение: Алгоритм, использующий структуру данных "куча" для упорядочивания элементов.

Пошаговая работа:

1. Строим max-кучу из массива
2. Корень кучи содержит максимальный элемент
3. Меняем корень с последним элементом
4. Восстанавливаем кучу
5. Повторяем, пока куча не пуста

Сложность: O(n log n) во всех случаях

Объяснение сложности:

· Построение кучи: O(n) операций
· Извлечение элементов: n извлечений × O(log n) = O(n log n)
· Общая сложность: O(n) + O(n log n) = O(n log n)
· Преимущество: гарантированное время выполнения, не требует дополнительной памяти
· Недостаток: нестабильная сортировка

Пример:
Исходный массив: [4, 10, 3, 5, 1]
Строим кучу: [10, 5, 3, 4, 1]
Извлекаем 10: [5, 4, 3, 1, 10]
Извлекаем 5: [4, 1, 3, 5, 10]
Извлекаем 4: [3, 1, 4, 5, 10]
Извлекаем 3: [1, 3, 4, 5, 10]
Отсортированный массив: [1, 3, 4, 5, 10]

---

Алгоритмы поиска

8. Линейный поиск (Linear Search)

Определение: Последовательно проверяет элементы массива один за другим.

Пошаговая работа:

1. Начинаем с первого элемента
2. Сравниваем с искомым
3. Если найден - возвращаем индекс
4. Если дошли до конца - возвращаем -1

Сложность: O(n)

Объяснение сложности:

· Лучший случай (O(1)): элемент на первой позиции
· Средний случай (O(n)): элемент в середине массива, n/2 сравнений
· Худший случай (O(n)): элемент отсутствует или на последней позиции
· Преимущество: работает с любыми массивами, простая реализация
· Недостаток: медленный для больших массивов

Пример:
Массив: [2, 5, 8, 12, 16, 23, 38, 45]
Поиск элемента 16:
Проверяем 2 ≠ 16
Проверяем 5 ≠ 16
Проверяем 8 ≠ 16
Проверяем 12 ≠ 16
Проверяем 16 = 16 ✓
Элемент найден на позиции: 4

---

9. Бинарный поиск (Binary Search)

Определение: Работает на отсортированном массиве, делит диапазон поиска пополам на каждом шаге.

Пошаговая работа:

1. Определяем границы поиска
2. Находим средний элемент
3. Сравниваем с искомым
4. Сужаем диапазон поиска
5.Повторяем до нахождения или пустого диапазона

Сложность: O(log n)

Объяснение сложности:

· Каждый шаг уменьшает область поиска вдвое
· Количество шагов: log₂n
· Лучший случай (O(1)): элемент в середине массива
· Худший случай (O(log n)): элемент на границе или отсутствует
· Требование: массив должен быть отсортирован
· Эффективность: очень быстрый для больших массивов

Пример:
Массив: [3, 7, 14, 21, 29, 33, 42, 55, 67, 78]
Поиск элемента 29:
Шаг 1: left=0, right=9, mid=4 → arr[4]=29 = 29 ✓ найден
Элемент найден на позиции: 4

---

10. Интерполяционный поиск (Interpolation Search)

Определение: Улучшенный бинарный поиск для равномерно распределённых данных.

Пошаговая работа:

1. Вычисляем предполагаемую позицию по формуле интерполяции
2. Сравниваем найденный элемент с искомым
3. Сужаем область поиска
4. Повторяем до нахождения

Сложность:

· Лучший случай: O(1)
· Средний случай: O(log log n)
· Худший случай: O(n)

Объяснение сложности:

· Лучший случай (O(1)): точное предсказание позиции
· Средний случай (O(log log n)): для равномерно распределенных данных
  · Каждый шаг значительно уменьшает область поиска
· Худший случай (O(n)): для неравномерных данных (экспоненциальное распределение)
  · Вырождается в линейный поиск
· Эффективность: зависит от равномерности распределения данных

Пример:
Массив: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
Поиск элемента 60:
Шаг 1: pos = 0 + ((60-10)*(9-0))/(100-10) = 5
arr[5] = 60 = 60 ✓ найден
Элемент найден на позиции: 5

---

11. Поиск Фибоначчи (Fibonacci Search)

Определение: Алгоритм поиска, использующий числа Фибоначчи для деления массива.

Пошаговая работа:

1. Находим число Фибоначчи ≥ длины массива
2. Определяем позиции для сравнения
3. Сравниваем элемент в точке разделения
4. Сдвигаем область поиска
5. Повторяем до нахождения

Сложность: O(log n)

Объяснение сложности:

· Основан на числах Фибоначчи: F(k) ≈ φ^k/√5, где φ = (1+√5)/2 ≈ 1.618
· Количество шагов: logᵩn ≈ 1.44 log₂n
· Сравнение с бинарным поиском:
  · Бинарный: всегда делит пополам
  · Фибоначчи: использует золотое сечение
· Преимущество: избегает деления, использует только сложение/вычитание
· Эффективность: сравнима с бинарным поиском

Пример:
Массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Поиск элемента 85:
Шаг 1: проверяем позицию 7 → arr[7]=82 < 85 → сдвиг вправо
Шаг 2: проверяем позицию 9 → arr[9]=90 > 85 → сдвиг влево
Шаг 3: проверяем позицию 8 → arr[8]=85 = 85 ✓ найден
Элемент найден на позиции: 8

---

