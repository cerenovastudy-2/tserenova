#  Алгоритмы и структуры данных


Алгоритмы сортировки и поиска

Алгоритмы сортировки

1. Сортировка выбором (Selection Sort)

Определение: Алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части.

Пошаговая работа:

1. Начинаем с первого элемента как текущего минимального
2. Проходим по оставшейся части массива для поиска реального минимального элемента
3. Когда находим элемент меньше текущего минимального - запоминаем его позицию
4. После прохода всей неотсортированной части меняем местами найденный минимальный элемент с первым элементом неотсортированной части
5. Увеличиваем начало отсортированной части на 1 позицию
6. Повторяем шаги 1-5 для оставшейся неотсортированной части

Сложность: O(n²) во всех случаях

Объяснение сложности:

· Внешний цикл: выполняется n-1 раз
· Внутренний цикл: на i-ой итерации выполняется n-i сравнений
· Общее количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2

Пример выполнения:
Исходный массив: [64, 25, 12, 22, 11]

Шаг 1: Ищем минимальный в [64, 25, 12, 22, 11]
Найден минимальный: 11 на позиции 4
Меняем 64 и 11: [11, 25, 12, 22, 64]

Шаг 2: Ищем минимальный в [25, 12, 22, 64]
Найден минимальный: 12 на позиции 2
Меняем 25 и 12: [11, 12, 25, 22, 64]

Шаг 3: Ищем минимальный в [25, 22, 64]
Найден минимальный: 22 на позиции 3
Меняем 25 и 22: [11, 12, 22, 25, 64]

Шаг 4: Ищем минимальный в [25, 64]
Найден минимальный: 25 на позиции 3
Меняем 25 и 25: [11, 12, 22, 25, 64]

Отсортированный массив: [11, 12, 22, 25, 64]

---

2. Сортировка пузырьком (Bubble Sort)

Определение: Простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами при неправильном порядке.

Пошаговая работа:

1. Устанавливаем флаг обмена в false
2. Проходим по массиву от начала до конца-1
3. Сравниваем текущий элемент со следующим
4. Если текущий элемент больше следующего - меняем их местами и устанавливаем флаг обмена в true
5. После каждого прохода самый большой элемент "всплывает" в конец
6. в конец
7. Уменьшаем границу неотсортированной части на 1
8. Повторяем шаги  Уменьшаем границу неотсортированной части на1-6 пока не 1
9. Повторяем шаги 1-6 пока не будет будет прохода без прохода без обмен обменовов

Сложность:

· Лучший случай: O(n)
· Средний

Сложность:

· Лучший случай: O(n)
· Средний случай: случай: O(n²)
  O(n²)
· Худ- Худший случай:ший случай: O(n O(n²)

**Объяс²)

Объяснение сложнение сложности:
-ности**:

· Л Лучший случай:учший случай: массив массив уже отсортирован, уже отсортирован, нужен один нужен один проход
  проход
  -- Худший случай Худший случай: ма: массив отсортированссив отсортирован в обра в обратном порядке,тном порядке, нужны n нужны n проходов проходов

**Пример

Пример выполнения:
 выполнения**:

ИсИсходный массивходный массив:: [5, 1 [5, 1, , 4, 24, 2, , 8]

Проход8]

Проход 1:
1:
СравСравниваем 5ниваем 5 и 1 → и 1 → 5 5 > 1 → > 1 → меняем меняем: [1,: [1, 5, 5, 4, 4, 2,  2, 8]
Срав8]
Сравниваемниваем 5 и  5 и 4 →4 → 5 >  5 > 4 →4 → меняем меняем: [1, : [1, 4, 5, 2, 8]
Сравниваем 5 и 2 → 4, 5, 2, 8]
Сравниваем 5 и 2 → 5 > 2 → меняем5 > 2 → меняем:: [1, 4 [1, 4, , 2, 52, 5, 8, 8]
]
СравниваемСравниваем 5 5 и 8 и 8 → 5 < 8 → → 5 < 8 → не меня не меняем

Проем

Проход 2:
ход 2:
СравСравниваем 1ниваем 1 и  и 4 → 1 < 4 → не меняем4 → 1 < 4 → не меняем
Сравни
Сравниваем 4ваем 4 и 2 → и 2 → 4 > 2 → 4 > 2 → меняем: [1, 2,  меняем: [1, 2, 4, 5, 4, 5, 88]
Сравниваем]
Сравниваем  4 и 5 → 4 < 5 → не4 и 5 → 4 < 5 → не меняем

Проход 3:
Сравниваем 1 и 2 → 1 < меняем

Проход 3:
Сравниваем 1 и 2 → 1 <  2 → не меняем
Срав2 → не меняем
Сравниваем 2 иниваем 2 и 4 → 2 <  4 → 2 < 4 → не4 → не меняем
Н меняем
Нет обет обменов - заверменов - завершаемшаем

Отсорти

Отсортированный массив: [1рованный массив: [1, , 2, 42, 4, 5, 8]

, 5, 8]

---

3. С---

3. Сортировкаортировка встав вставками (ками (Insertion Sort)

Insertion Sort)

Определение: Алгоритм строит отсортированную часть массиОпределение: Алгоритм строит отсортированную часть массива, вва, вставляяставляя каждый новый каждый новый элемент на правильное элемент на правильное место.

**По место.Пошаговаяшаговая работа:
1 работа**:

1. Начина. Начинаем со второго элементаем со второго элемента как теку как текущего для вставщего для вставки
   ки
   2.2. Сохра Сохраняем значениеняем значение текущего элемента текущего элемента в переменную key в переменную key
   3
2. Сравниваем. Сравниваем key с key с элементами отсорти элементами отсортированной частированной части справа на справа налеволево
3. С
4. Сдвигаем элементы больдвигаем элементы большие keyшие key на одну позицию вправо
5. на одну позицию вправо
6. Когда находим Когда находим позицию где ле позицию где левый элемент ≤ key -вый элемент ≤ key - вставляем вставляем key
7. Пере key
8. Переходиходим к следующему элеменм к следующему элементу и повторту и повторяем шаяем шаги 2-5ги 2-5

Сложность:
Сложность:

· Лучший- Лучший случай: случай: O(n)
· O(n)
· Средний случай: O(n²)
  Средний случай: O(n²)
· Худший случай:- Худший случай: O(n O(n²)

**Об²)

Объяснениеъяснение сложности:

· Лучший случай: массив уже отсортирован, каждый элемент сразу на месте
· Худший случай: массив отсортирован в обратном порядке, каждый элемент сдвигается в начало

Пример выполнения:
И сложности**:
- **Лучший случай**: массив уже отсортирован, каждый элемент сразу на месте
- **Худший случай**: массив отсортирован в обратном порядке, каждый элемент сдвигается в начало

**Пример выполнения**:

Исходный массив: [12, 11, 13, 5, 6]

сходный массив: [12, 11, 13, 5, 6]

Шаг 1Шаг 1: Вставля: Вставляем 11 (ем 11 (индекс индекс 1)
Сравниваем1)
Сравниваем 12 12 и 11 → и 11 → 12 >  12 > 11 →11 → сдвига сдвигаем 12ем 12: [12: [12, 12,, 12, 13 13, 5,, 5, 6]
Вставляем 11: [11, 12, 13,  6]
Вставляем 11: [11, 12, 13, 5, 6]

5, 6]

Шаг Шаг 2: В2: Вставляемставляем  13 (индекс 13 (индекс 2)
Сравниваем 12 и 13 → 12 < 13 → в2)
Сравниваем 12 и 13 → 12 < 13 → вставляем ставляем 13: [1113: [11, , 12,12, 13,  13, 5, 65, 6]

Ш]

Шаг 3:аг 3: Вставляем Вставляем 5 ( 5 (индекс 3индекс 3)
С)
Сравниравниваем ваем 1313 и 5 → 13 > и 5 → 13 > 5 → с 5 → сдвигадвигаем ем 13:13: [11, [11, 12, 12,  13, 1313, 13, 6]
Сравниваем 12 и 5 → 12 > 5 → сдвигаем 12: [11, 12, 12, 13, 6]
Сравниваем 11 и 5 → 11 > 5 → сдвига, 6]
Сравниваем 12 и 5 → 12 > 5 → сдвигаем 12: [11, 12, 12, 13, 6]
Сравниваем 11 и 5 → 11 > 5 → сем 11: [11, 11, 12, 13, 6]
Вставляем 5: [5, 11, 12, 13, 6]

Шаг 4: Вставляем 6 (индекс 4)
Сравниваем 13 и 6 → 13 > 6 → сдвигаем 13: [5, 11, 12, 13, 13]
Сравнидвигаем 11: [11, 11, 12, 13, 6]
Вставляем 5: [5, 11, 12, 13, 6]

Шаг 4: Вставляем 6 (индекс 4)
Сравниваем 13 и 6 → 13 > 6 → сдвигаем 13: [5, 11, 12, 13, 13]
Сравниваем 12 и ваем 12 и 6 →6 → 12 >  12 > 6 → сдвига6 → сдвигаем ем 12:12: [5 [5, 11, 12,, 11, 12, 12 12, 13]
, 13]
СравСравниваем 11ниваем 11 и  и 6 → 11 >6 → 11 > 6 6 → сдви → сдвигаем 11гаем 11: [5: [5, 11, 11, 11, 11, 12, 12, 13]
Сравниваем , 13]
Сравниваем 55 и 6 и 6 → 5 < 6 → вставля → 5 < 6 → вставляем 6:ем 6: [5, 6, 11 [5, 6, 11, 12, 13, 12, 13]

Отсортированный массив:]

Отсортированный массив: [5, 6, [5, 6, 11, 12, 11, 12, 13]

---

## 13]

---

4 4. Сортировка с. Сортировка слиянием (лиянием (Merge Sort)

**ОпределениеMerge Sort)

Определение: Алгоритм "раз**: Алгоритм "раздеделяй и властвуляй и властвуй",й", который рекурсивно который рекурсивно дели делит массив пополамт массив пополам и объединяет и объединяет отс отсортированные части.

**Пошаортированные части.

Поговая работа:

1. Если массив содержитшаговая работа**:
2. Если массив содержит 0 или 1 элемент - он уже отсортирован
3. Находим середи 0 или 1 элемент - он уже отсортирован
4. Находим середину массива
5. Рну массива
6. Рекурсивно сортируем левую половину
7. Рекурсивно сортируекурсивно сортируем левую половину
8. Рекурсивноем правую половину
   сортируем правую половину
9. Объединяем две отсортированные полови5. Объединяем две отсортированные половины:
   · Сравны:
   · Сравниваем первые элементыниваем первые элементы обеих половин
     обеих половин - Выбираем меньший и добавляем в результат
   · Выбираем меньший и добавляем в результат
   · Перемеща
   · Перемещаем указаем указатель в половине откуда взяли элемент
---

5. Сортировка Шелла (Shell Sort)

Определение: Улучшенная версия сортировки вставками с использованием убывающих интервалов.

Пошаговая работа:

1. Выбираем начальный шаг (gap)
2. Сортируем элементы с этим шагом
3. Уменьшаем шаг
4. Завершаем сортировку с шагом 1

Сложность:

· Лучший случай: O(n log n)
· Средний случай: O(n log n)
· Худший случай: O(n²)

Объяснение сложности:

· Зависит от последовательности шагов:
  · Последовательность Шелла: O(n²)
  · Последовательность Хиббарда: O(n^(3/2))
  · Последовательность Пратта: O(n log²n)
· Идея: крупные шаги перемещают элементы ближе к их конечным позициям
· Эффективность: между O(n log n) и O(n²) в зависимости от выбора шагов

Пример:
Исходный массив: [23, 12, 1, 8, 34, 54, 2, 3]
Шаг gap=4: [23, 12, 1, 8, 34, 54, 2, 3]
Шаг gap=2: [1, 8, 2, 3, 23, 12, 34, 54]
Шаг gap=1: [1, 2, 3, 8, 12, 23, 34, 54]
Отсортированный массив: [1, 2, 3, 8, 12, 23, 34, 54]

---
6. Быстрая сортировка (Quick Sort)

Определение: Алгоритм "разделяй и властвуй", который выбирает опорный элемент и делит массив на части.

Пошаговая работа:

1. Выбираем опорный элемент (обычно последний элемент массива)
2. Проходим по массиву слева направо, перемещая элементы меньше опорного влево
3. Элементы больше опорного остаются справа
4. Помещаем опорный элемент между этими двумя группами
5. Рекурсивно применяем алгоритм к левой и правой частям
6. Объединяем результаты

Сложность:

· Лучший случай: O(n log n)
· Средний случай: O(n log n)
· Худший случай: O(n²)

Объяснение сложности:

· Лучший/средний случай (O(n log n)): когда опорный элемент делит массив на примерно равные части
  · Глубина рекурсии: O(log n)
  · Работа на каждом уровне: O(n)
· Худший случай (O(n²)): когда массив уже отсортирован и опорный элемент всегда минимальный или максимальный
  · Глубина рекурсии: O(n)
  · Работа на каждом уровне: O(n)

Пример выполнения:
Исходный массив: [10, 7, 8, 9, 1, 5]
Опорный элемент: 5

Разделение:
- Элементы меньше 5: [1]
- Опорный элемент: 5
- Элементы больше 5: [10, 7, 8, 9]

Рекурсивная сортировка левой части [1]:
- Уже отсортирован

Рекурсивная сортировка правой части [10, 7, 8, 9]:
Опорный элемент: 9
- Элементы меньше 9: [7, 8]
- Опорный элемент: 9
- Элементы больше 9: [10]

Рекурсивная сортировка [7, 8]:
Опорный элемент: 8
- Элементы меньше 8: [7]
- Опорный элемент: 8
- Элементы больше 8: []

Объединяем все части:
[1] + [5] + [7, 8] + [9] + [10] = [1, 5, 7, 8, 9, 10]

Отсортированный массив: [1, 5, 7, 8, 9, 10]

---

7. Пирамидальная сортировка (Heap Sort)

Определение: Алгоритм, использующий структуру данных "куча" для упорядочивания элементов.

Пошаговая работа:

1. Преобразуем массив в max-кучу (родитель ≥ потомков)
2. Находим самый большой элемент (в корне кучи)
3. Меняем его с последним элементом массива
4. Уменьшаем размер кучи на 1
5. Восстанавливаем свойства max-кучи для нового корня
6. Повторяем шаги 2-5, пока куча не пуста

Сложность: O(n log n) во всех случаях

Объяснение сложности:

· Построение кучи: O(n) операций
· Извлечение элементов: n извлечений × O(log n) = O(n log n)
· Общая сложность: O(n) + O(n log n) = O(n log n)

Пример выполнения:
Исходный массив: [4, 10, 3, 5, 1]

Шаг 1: Построение max-кучи
Исходный: [4, 10, 3, 5, 1]
После heapify: [10, 5, 3, 4, 1]

Шаг 2: Извлекаем максимальный элемент (10)
Меняем 10 и 1: [1, 5, 3, 4, 10]
Восстанавливаем кучу: [5, 4, 3, 1, 10]

Шаг 3: Извлекаем максимальный элемент (5)
Меняем 5 и 1: [1, 4, 3, 5, 10]
Восстанавливаем кучу: [4, 1, 3, 5, 10]

Шаг 4: Извлекаем максимальный элемент (4)
Меняем 4 и 3: [3, 1, 4, 5, 10]
Восстанавливаем кучу: [3, 1, 4, 5, 10]

Шаг 5: Извлекаем максимальный элемент (3)
Меняем 3 и 1: [1, 3, 4, 5, 10]

Отсортированный массив: [1, 3, 4, 5, 10]

---

8. Линейный поиск (Linear Search)

Определение: Последовательно проверяет элементы массива один за другим.

Пошаговая работа:

1. Начинаем с первого элемента массива
2. Сравниваем текущий элемент с искомым значением
3. Если элементы равны - возвращаем индекс текущего элемента
4. Если не равны - переходим к следующему элементу
5. Повторяем шаги 2-4 до нахождения элемента или конца массива
6. Если элемент не найден - возвращаем -1

Сложность: O(n)

Объяснение сложности:

· Лучший случай (O(1)): элемент находится на первой позиции
· Средний случай (O(n)): элемент находится в середине массива
· Худший случай (O(n)): элемент отсутствует или находится на последней позиции

Пример выполнения:
Массив: [3, 5, 2, 7, 9, 1, 4]
Ищем элемент: 7

Шаг 1: Проверяем элемент 3 на позиции 0 → 3 ≠ 7
Шаг 2: Проверяем элемент 5 на позиции 1 → 5 ≠ 7
Шаг 3: Проверяем элемент 2 на позиции 2 → 2 ≠ 7
Шаг 4: Проверяем элемент 7 на позиции 3 → 7 = 7 ✓

Элемент найден на позиции: 3

---

9. Бинарный поиск (Binary Search)

Определение: Работает на отсортированном массиве, делит диапазон поиска пополам на каждом шаге.

Пошаговая работа:

1. Определяем начальные границы поиска (left = 0, right = n-1)
2. Вычисляем средний индекс: mid = (left + right) // 2
3. Сравниваем элемент в mid с искомым значением
4.Если равны - возвращаем mid
5. Если искомое значение меньше - ищем в левой половине (right = mid - 1)
6. Если искомое значение больше - ищем в правой половине (left = mid + 1)
7. Повторяем шаги 2-6 пока left ≤ right
8. Если элемент не найден - возвращаем -1

Сложность: O(log n)

Объяснение сложности:

· Каждый шаг уменьшает область поиска вдвое
· Количество шагов: log₂n

Пример выполнения:
Отсортированный массив: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Ищем элемент: 7

Шаг 1: left=0, right=9, mid=4 → arr[4]=9 > 7 → ищем слева
Шаг 2: left=0, right=3, mid=1 → arr[1]=3 < 7 → ищем справа
Шаг 3: left=2, right=3, mid=2 → arr[2]=5 < 7 → ищем справа
Шаг 4: left=3, right=3, mid=3 → arr[3]=7 = 7 ✓

Элемент найден на позиции: 3

---

10. Интерполяционный поиск (Interpolation Search)

Определение: Улучшенный бинарный поиск для равномерно распределённых данных.

Пошаговая работа:

1. Вычисляем предполагаемую позицию по формуле:
   pos = low + ((target - arr[low]) × (high - low)) / (arr[high] - arr[low])
2. Сравниваем элемент в позиции pos с искомым значением
3. Если равны - возвращаем pos
4. Если искомое значение меньше - ищем в левой части (high = pos - 1)
5. Если искомое значение больше - ищем в правой части (low = pos + 1)
6. Повторяем шаги 1-5 пока low ≤ high и target в диапазоне [arr[low], arr[high]]
7. Если элемент не найден - возвращаем -1

Сложность:

· Лучший случай: O(1)
· Средний случай: O(log log n)
· Худший случай: O(n)

Объяснение сложности:

· Лучший случай: точное предсказание позиции
· Средний случай: для равномерных данных быстро сужает область поиска
· Худший случай: для неравномерных данных вырождается в линейный поиск

Пример выполнения:
Отсортированный массив: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
Ищем элемент: 60

Шаг 1: low=0, high=9
pos = 0 + ((60-10)×(9-0))/(100-10) = 0 + (50×9)/90 = 5
arr[5] = 60 = 60 ✓

Элемент найден на позиции: 5

---

11. Поиск Фибоначчи (Fibonacci Search)

Определение: Алгоритм поиска, использующий числа Фибоначчи для деления массива.

Пошаговая работа:

1. Находим наименьшее число Фибоначчи F(k) ≥ длины массива
2. Инициализируем переменные: fibM = F(k), fibM1 = F(k-1), fibM2 = F(k-2)
3. Устанавливаем начальный offset = -1
4. Пока fibM > 1:
   · Вычисляем индекс i = min(offset + fibM2, n-1)
   · Сравниваем arr[i] с искомым значением
   · Если равны - возвращаем i
   · Если искомое значение больше - сдвигаемся вправо, обновляем числа Фибоначчи
   · Если искомое значение меньше - сдвигаемся влево, обновляем числа Фибоначчи
5. Проверяем последний элемент если нужно
6. Если элемент не найден - возвращаем -1

Сложность: O(log n)

Объяснение сложности:

· Основан на свойствах чисел Фибоначчи
· Каждый шаг уменьшает область поиска используя золотое сечение
· Эффективность сравнима с бинарным поиском

Пример выполнения:
Отсортированный массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Ищем элемент: 85

Числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13 (F(7)=13 ≥ 11)

Шаг 1: fibM=13, fibM1=8, fibM2=5, offset=-1
i = min(-1 + 5, 10) = 4 → arr[4]=45 < 85 → сдвиг вправо

Шаг 2: fibM=8, fibM1=5, fibM2=3, offset=4
i = min(4 + 3, 10) = 7 → arr[7]=82 < 85 → сдвиг вправо

Шаг 3: fibM=5, fibM1=3, fibM2=2, offset=7
i = min(7 + 2, 10) = 9 → arr[9]=90 > 85 → сдвиг влево

Шаг 4: fibM=2, fibM1=1, fibM2=1, offset=7
i = min(7 + 1, 10) = 8 → arr[8]=85 = 85 ✓

Элемент найден на позиции: 8
