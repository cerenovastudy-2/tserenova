Алгоритмы сортировки

---

1. Блочная (корзинная) сортировка (Bucket Sort)

1.1. Определение
Алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. Каждая корзина сортируется отдельно, после чего отсортированные корзины объединяются в один массив.
1.3. Результат работы
Исходный массив: [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
Отсортированный массив: [0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]
1.4. Объяснение работы кода

· Строки 6-8: Создается список пустых корзин (buckets).
· Строки 11-13: Каждое число из исходного массива помещается в одну из корзин. Например, число 0.42 при num_buckets=7 попадет в корзину с индексом int(0.42 * 7) = 2.
· Строки 16-17: Каждая непустая корзина сортируется (в данном случае встроенным методом sort()).
· Строки 20-24: Элементы из всех корзин последовательно извлекаются и записываются обратно в исходный массив, формируя отсортированную последовательность.

1.5. Оценка временной сложности

· Лучший случай: O(n + k)
· Средний случай: O(n + k)
· Худший случай: O(n²)

1.6. Объяснение оценки сложности

· Лучший/Средний случай: Элементы равномерно распределяются по корзинам. Распределение (O(n)) и сборка (O(n)) выполняются за линейное время, а сортировка k корзин в среднем занимает O(n) или O(n log n), если использовать эффективную сортировку.
· Худший случай: Все элементы попадают в одну корзину, и алгоритм вырождается в сортировку вставками (или другую используемую внутри), что дает O(n²).

---

2. Блинная сортировка (Pancake Sort)

1. Определение
Алгоритм сортировки, основанный на операции переворота префикса массива. Единственная разрешенная операция — переворот элементов от начала до выбранного индекса.
3. Результат работы
Исходный массив: [3, 1, 4, 2, 7, 5, 6]
Переворот до макс элемента: [7, 2, 4, 1, 3, 5, 6]
Переворот неотсортированной части: [6, 5, 3, 1, 4, 2, 7]
Переворот до макс элемента: [6, 5, 3, 1, 4, 2, 7]
Переворот неотсортированной части: [2, 4, 1, 3, 5, 6, 7]
Переворот до макс элемента: [4, 2, 1, 3, 5, 6, 7]
Переворот неотсортированной части: [3, 1, 2, 4, 5, 6, 7]
Переворот до макс элемента: [3, 1, 2, 4, 5, 6, 7]
Переворот неотсортированной части: [2, 1, 3, 4, 5, 6, 7]
Переворот до макс элемента: [2, 1, 3, 4, 5, 6, 7]
Переворот неотсортированной части: [1, 2, 3, 4, 5, 6, 7]
Отсортированный массив: [1, 2, 3, 4, 5, 6, 7]

4. Объяснение работы кода

· Строка 7: Внешний цикл постепенно уменьшает размер неотсортированной части.
· Строка 9: Находим индекс максимального элемента в текущей неотсортированной части.
· Строки 12-16: Если максимальный элемент не первый, переворачиваем часть массива до него.
· Строки 18-20: Переворачиваем всю неотсортированную часть, чтобы максимальный элемент оказался на своем месте.

5. Оценка временной сложности

· Лучший случай: O(n²)
· Средний случай: O(n²)
· Худший случай: O(n²)

6. Объяснение оценки сложности
Каждый элемент требует до двух переворотов, и для каждого элемента мы ищем максимум (O(n)). Общая сложность: O(n) × O(n) = O(n²).

---

2. Сортировка бусинами (Bead Sort)

1. Определение
Алгоритм, моделирующий естественное поведение бусин, падающих вниз под действием гравитации. Работает только с неотрицательными целыми числами.

3. Результат работы
4. Исходный массив: [3, 1, 4, 2, 2]
Отсортированный массив: [1, 2, 2, 3, 4]

4. Объяснение работы кода

· Строки 11-13: Проверяем валидность входных данных.
· Строки 17-18: Создаем матрицу (абак) для представления бусин.
· Строки 21-23: Расставляем бусины согласно значениям массива.
· Строки 26-35: Симулируем падение бусин под действием гравитации.
· Строка 38: Восстанавливаем отсортированный массив, подсчитывая бусины в каждой строке.

5. Оценка временной сложности

· Лучший случай: O(n)
· Средний случай: O(n)
· Худший случай: O(n)

6. Объяснение оценки сложности
Теоретическая сложность O(n), но на практике ограничена максимальным значением в массиве. Эффективность зависит от реализации и аппаратных возможностей.

---

Алгоритмы поиска

---

1. Поиск скачками (Jump Search)

1. Определение
Алгоритм поиска в отсортированном массиве, который "прыгает" через фиксированное количество элементов, чтобы быстро сузить диапазон поиска.
3. Результат работы

Отсортированный массив: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
Цель поиска: 55
Элемент найден на индексе: 10

4. Объяснение работы кода

· Строка 10: Определяем размер прыжка как √n.
· Строки 13-17: Прыгаем вперед, пока не найдем блок, где может находиться искомый элемент.
· Строки 20-23: Выполняем линейный поиск в найденном блоке.
· Строки 26-27: Возвращаем индекс, если элемент найден.

5. Оценка временной сложности

· Лучший случай: O(1)
· Средний случай: O(√n)
· Худший случай: O(√n)

6. Объяснение оценки сложности
Алгоритм делает O(√n) прыжков и затем O(√n) сравнений в блоке, что дает общую сложность O(√n).

---

2. Экспоненциальный поиск (Exponential Search)

1. Определение
Алгоритм, который сначала находит диапазон экспоненциальным увеличением границы, а затем выполняет бинарный поиск в этом диапазоне.

3. Результат работы
Отсортированный массив: [2, 3, 4, 10, 15, 20, 25, 30, 35, 40, 45, 50]
Цель поиска: 35
Элемент найден на индексе: 8
4. Объяснение работы кода

· Строки 2-12: Стандартная реализация бинарного поиска.
· Строки 20-21: Проверяем первый элемент.
· Строки 24-26: Экспоненциально увеличиваем границу поиска.
· Строки 29-30: Определяем границы для бинарного поиска.
· Строка 31: Выполняем бинарный поиск в найденном диапазоне.

5. Оценка временной сложности

· Лучший случай: O(1)
· Средний случай: O(log n)
· Худший случай: O(log n)

6. Объяснение оценки сложности
Экспоненциальное нахождение диапазона занимает O(log n), и бинарный поиск также O(log n), что дает общую сложность O(log n).

---

3. Тернарный поиск (Ternary Search)

1. Определение
Алгоритм поиска, который делит отсортированный массив на три части и рекурсивно сужает область поиска.
3. Результат работы
Отсортированный массив: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Цель поиска: 6
Элемент найден на индексе: 5
4. Объяснение работы кода

· Строки 7-8: Делим текущий диапазон на три равные части.
· Строки 11-14: Проверяем граничные точки.
· Строки 17-22: Рекурсивно ищем в соответствующей трети массива.

5. Оценка временной сложности

· Лучший случай: O(1)
· Средний случай: O(log₃n)
· Худший случай: O(log₃n)

6. Объяснение оценки сложности
На каждом шаге алгоритм уменьшает область поиска в 3 раза, что дает логарифмическую сложность по основанию 3: O(log₃n).

