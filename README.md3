1. Сортировка выбором (Selection Sort) - C++
  Описание:
 На каждом шаге алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части. Процесс повторяется для оставшейся неотсортированной части массива.
 
 Результат выполнения:
Исходный массив: 64 25 12 22 11 
Отсортированный массив: 11 12 22 25 64 
 
 Сложность:
 O(n²) во всех случаях

 2. Сортировка пузырьком (Bubble Sort) - Python
    Описание:
Алгоритм многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. На каждой итерации самый большой элемент "всплывает" в конец массива.

Результат выполнения:
Исходный массив: 64 34 25 12 22 11 90 
Отсортированный массив: 11 12 22 25 34 64 90 

Сложность:
 O(n²) в худшем случае, O(n) в лучшем случае

3. Сортировка вставками (Insertion Sort) - C++
Описание:
Алгоритм строит отсортированную часть массива, последовательно вставляя каждый новый элемент в правильную позицию. Для этого он сравнивает текущий элемент с предыдущими и сдвигает элементы, пока не найдет правильное место.

Результат выполнения:
Исходный массив: 12 11 13 5 6 
Отсортированный массив: 5 6 11 12 13 

Сложность:
 O(n²) в худшем случае, O(n) в лучшем случае

 4. Сортировка слиянием (Merge Sort) - C++
 Описание:
  Алгоритм рекурсивно делит массив пополам до тех пор, пока не останутся массивы из одного элемента, затем сливает отсортированные части обратно. Используйте подход "разделяй и властвуй".

Результат выполнения:
Исходный массив: 38 27 43 3 9 82 10 
Отсортированный массив: 3 9 10 27 38 43 82 

  Сложность:
  O(n log n) во всех случаях

  5. Сортировка Шелла (Shell Sort) - Python
      Описание:
Улучшенная версия сортировки вставками, которая сортирует элементы, находящиеся на определенном расстоянии друг от друга. Расстояние постепенно уменьшается до 1, обеспечивая окончательную сортировку.

Результат выполнения:
Исходный массив: 12 34 54 2 3 
Отсортированный массив: 2 3 12 34 54 

Сложность:
 O(n log n) - O(n²) в зависимости от последовательности шагов

 6. Быстрая сортировка (Quick Sort) - Python
Описание:
Алгоритм выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше опорного. Затем рекурсивно сортирует обе части.

Результат выполнения:
Исходный массив: 10 7 8 9 1 5 
Отсортированный массив: 1 5 7 8 9 10 

Сложность:
O(n log n) в среднем случае, O(n²) в худшем случае

7. Пирамидальная сортировка (Heap Sort) - C++
Описание:
 Алгоритм строит max-heap из массива, затем последовательно извлекает максимальный элемент из кучи и помещает его в конец массива. Использует структуру данных "куча".

Результат выполнения:
Исходный массив: 12 11 13 5 6 7 
Отсортированный массив: 5 6 7 11 12 13 

Сложность:
 O(n log n) во всех случаях

 8. Линейный поиск (Linear Search) - Python
Описание:
Простейший алгоритм поиска, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент или не достигнет конца массива. Работает с любыми массивами.

Результат выполнения:
Элемент найден на позиции: 3

Сложность: 
O(n)

9. Бинарный поиск (Binary Search) - C++

Описание:
Эффективный алгоритм для поиска в отсортированном массиве, который на каждом шаге делит область поиска пополам. Сравнивает средний элемент с искомым значением и продолжает поиск в соответствующей половине.

Результат выполнения:
Элемент найден на позиции: 3

Сложность: 
O(log n)

10. Интерполяционный поиск (Interpolation Search) - C++
Описание:
Улучшенная версия бинарного поиска, которая предсказывает позицию искомого элемента на основе значений границ и самого элемента. Особенно эффективен для равномерно распределенных данных.

Результат выполнения:
Элемент найден на позиции: 4

Сложность:
O(log log n) в лучшем случае, O(n) в худшем случае

11. Поиск Фибоначчи (Fibonacci Search) - Python
Описание:
 Алгоритм использует числа Фибоначчи для определения позиций сравнения в отсортированном массиве. Делит массив на части в пропорциях, соответствующих числам Фибоначчи, что может быть эффективнее бинарного поиска.

Результат выполнения:
Элемент найден на позиции: 8

Сложность: O(log n)
